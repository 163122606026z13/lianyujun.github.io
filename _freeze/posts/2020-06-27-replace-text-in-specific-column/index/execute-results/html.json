{
  "hash": "998c4d34abb3de37efb68b3c08a29b40",
  "result": {
    "markdown": "---\ntitle: \"Replace text within all cells of a specific column in R\"\nsubtitle: \"Here's how to target specific column(s) in a `data.frame` or `tibble` to replace text within.\"\nauthor: \"Vikram B. Baliga\"\ncategories:\n  - R\n  - stringr\n  - dplyr\n  - tidyverse\n  - data-cleaning\ndate: 2020-06-27\ntoc: true\nimage: \"replace-text-in-specific-column.png\"\n---\n\n\nRecently, I needed to find a way to rename specific cells within one column of a\ntibble without affecting cells in other columns. I knew that\n`stringr::str_replace()` is awesome for this sort of thing, but I hadn't quite\ngrasped how I could target specific columns with it.\n\nFortunately,`dplyr::mutate_at()`, and newer mechanisms via `dplyr::across()`,\nseem to fit the bill. I'll run through a few examples in this post.\n\nWe'll start by loading `tidyverse`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) ## I'm  using v1.3.0.9000\n```\n:::\n\n\n## The data\n\nWe'll now generate an example `tibble` to work with which we will simply call\n`data`.\n\n*Code to make this object will be appended to the end of this post so we can get\nto the punchline faster. Look down there if you'd like to re-create this example\nfully on your own*\n\nHere's how `data` looks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata\n```\n:::\n\n\n    # A tibble: 100 × 5\n       subject       treatment      var1   var2   var3\n       <chr>         <chr>         <dbl>  <dbl>  <dbl>\n     1 subject_c 003 treatment z  0.452  0.464  0.231 \n     2 subject_c 003 treatment y  0.0412 0.165  0.350 \n     3 subject_c 003 treatment y -0.422  0.585  0.605 \n     4 subject_b 003 treatment z -2.05   0.271  0.453 \n     5 subject_c 003 treatment x  1.13   0.230  0.447 \n     6 subject_b 003 treatment x -1.46   0.691  0.413 \n     7 subject_b 003 treatment z  0.740  0.283  0.0504\n     8 subject_b 003 treatment y  1.91   0.810  0.587 \n     9 subject_c 003 treatment y -1.44   0.0939 0.433 \n    10 subject_a 003 treatment y  0.702  0.822  0.121 \n    # … with 90 more rows\n\n## The issue\n\nNow say we want to replace the contents of `data$subject` with something less\ntedious. Right now, each subject name has `003` appended to it and we'd like to\nshave these parts off the names.\n\n`stringr::str_replace()` is great for replacing text that fits a specified\ncriterion. So we could simply tell `str_replace()` to target instances of `003`\nwithin the `subject` column. But the object fed into `str_replace()` needs to be\na vector, which can be awkward to pull from a tibble. Moreover, we'd like to do\nthis safely and ensure that no other columns in the tibble are affected.\n\n## Use `mutate_at()` with `str_replace()`\n\nFortunately, I found that `dplyr::mutate_at()` can help us target column(s) of\ninterest (here `subject`) and leave other columns untouched.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenamed_data <- \n  data %>% \n  mutate_at(\"subject\", str_replace, \" 003\", \"\")\nrenamed_data\n```\n:::\n\n\n    # A tibble: 100 x 5\n      subject   treatment      var1   var2   var3\n      <chr>     <chr>         <dbl>  <dbl>  <dbl>\n    1 subject_c treatment z  0.452  0.464  0.231 \n    2 subject_c treatment y  0.0412 0.165  0.350 \n    3 subject_c treatment y -0.422  0.585  0.605 \n    4 subject_b treatment z -2.05   0.271  0.453 \n    5 subject_c treatment x  1.13   0.230  0.447 \n    6 subject_b treatment x -1.46   0.691  0.413 \n    7 subject_b treatment z  0.740  0.283  0.0504\n    8 subject_b treatment y  1.91   0.810  0.587 \n    9 subject_c treatment y -1.44   0.0939 0.433 \n    10 subject_a treatment y  0.702  0.822  0.121 \n    # … with 90 more rows\n\nNice!\n\nBy using `dplyr::mutate_at()`, we are specifiying that `str_replace()` should\ntarget the `subject` column only and take all instances of `003` and replace\nthem with nothing (`\"\"`).\n\nFor those who prefer to not use pipes, we can accomplish the same thing by\nspecifying `data` as the first argument in `mutate_at()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenamed_data_no_pipe <- \n  mutate_at(data, \"subject\", str_replace, \" 003\", \"\")\nrenamed_data_no_pipe\n```\n:::\n\n\n    # A tibble: 100 x 5\n       subject   treatment      var1   var2   var3\n       <chr>     <chr>         <dbl>  <dbl>  <dbl>\n     1 subject_c treatment z  0.452  0.464  0.231 \n     2 subject_c treatment y  0.0412 0.165  0.350 \n     3 subject_c treatment y -0.422  0.585  0.605 \n     4 subject_b treatment z -2.05   0.271  0.453 \n     5 subject_c treatment x  1.13   0.230  0.447 \n     6 subject_b treatment x -1.46   0.691  0.413 \n     7 subject_b treatment z  0.740  0.283  0.0504\n     8 subject_b treatment y  1.91   0.810  0.587 \n     9 subject_c treatment y -1.44   0.0939 0.433 \n    10 subject_a treatment y  0.702  0.822  0.121 \n    # … with 90 more rows\n\n## Use `mutate()` and `across()` with `str_replace()`\n\nI should note that the `_at` component of `dplyr` has now been considered\n\"superseded\". Instead, the authors of `dplyr` recommend we use `dplyr::across()`\nto target our column(s) of interest. So we can write another version of the\nabove:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenamed_data_across <-\n  data %>%\n  mutate(across(\"subject\", str_replace, \" 003\", \"\"))\nrenamed_data_across\n```\n:::\n\n\n    # A tibble: 100 x 5\n       subject   treatment      var1   var2   var3\n       <chr>     <chr>         <dbl>  <dbl>  <dbl>\n     1 subject_c treatment z  0.452  0.464  0.231 \n     2 subject_c treatment y  0.0412 0.165  0.350 \n     3 subject_c treatment y -0.422  0.585  0.605 \n     4 subject_b treatment z -2.05   0.271  0.453 \n     5 subject_c treatment x  1.13   0.230  0.447 \n     6 subject_b treatment x -1.46   0.691  0.413 \n     7 subject_b treatment z  0.740  0.283  0.0504\n     8 subject_b treatment y  1.91   0.810  0.587 \n     9 subject_c treatment y -1.44   0.0939 0.433 \n    10 subject_a treatment y  0.702  0.822  0.121 \n    # … with 90 more rows\n\nEither way, we are able to trim off the extra text in `subject` names and avoid\nthe potential of affecting other columns.\n\n## Data\n\nHere's the code that was used to create `data`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrings_subs   <- c(\"subject_a 003\", \"subject_b 003\", \"subject_c 003\")\nstrings_treats <- c(\"treatment x\", \"treatment y\", \"treatment z\")\n\nset.seed(123)\ndata <- \n  tibble::tibble(subject   = sample(strings_subs,   100, replace = TRUE),\n                 treatment = sample(strings_treats, 100, replace = TRUE),\n                 var1 = rnorm(100, 0, 1),\n                 var2 = runif(100, 0, 1),\n                 var3 = rbeta(100, 1, 1))\n```\n:::\n\n\nThat's all!\n\n🐢\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}